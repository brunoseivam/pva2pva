<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>pva2pva: QSRV PVD record types</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">pva2pva
   &#160;<span id="projectnumber">1.2.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">QSRV PVD record types </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Several additional process database record types are provided along with QSRV which make use of pvData container classes. These records include some fields which are only accessible via PV Access. Device support for these record types must be written in C++.</p>
<ul>
<li>svectorin/out</li>
<li>columnarin/out</li>
<li>ndain</li>
<li>statBin</li>
<li>pvstructin</li>
</ul>
<p>All of these record types provide custom device support (dset) struct definitions. eg. 'struct svectorindset'</p>
<h1><a class="anchor" id="qsrv_svector"></a>
svectorin/out record types</h1>
<p>The svectorin/out records are analogous to to aai/aao record types in EPICS Base, with different management of array allocations. The aai/aao types manage a C array which device support copies samples to/from. The svectorin/out use an epics::pvData::shared_vector&lt;&gt; to allow immutable array data references to be moved in/out without copying.</p>
<p>Configuration is similar to aai/aao, with the FTVL field being required to specify the array element type.</p>
<p>Unlike aai/aao the NELM field is not required. It may be set to enable a limited compatibility mode in which the NELM elements may be read (but not written) via Channel Access.</p>
<p>Device support code for svectorin needs to populate a shared_vector instance of the correct type, and assign it to VAL. Assigning an array of an incorrect type is an error, VAL will be cleared and an the record alarmed.</p>
<div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * record(svectorin, &quot;myrec&quot;) {</span></div><div class="line"><span class="comment"> *     field(DTYP, &quot;My Support&quot;)</span></div><div class="line"><span class="comment"> *     field(FTVL, &quot;DOUBLE&quot;)</span></div><div class="line"><span class="comment"> *     field(NELM, &quot;100&quot;) # only needed for CA read access</span></div><div class="line"><span class="comment"> * }</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="preprocessor">#include &lt;svectorinRecord.h&gt;</span></div><div class="line">...</div><div class="line">static</div><div class="line"><span class="keywordtype">long</span> read_my_array(svectorinRecord *prec) {</div><div class="line">    epics::pvData::shared_vector&lt;double&gt; arr(2);</div><div class="line">    arr[0] = 1.0;</div><div class="line">    arr[1] = 2.0;</div><div class="line">    prec-&gt;val = epics::pvData::static_shared_vector_cast&lt;<span class="keyword">const</span> <span class="keywordtype">void</span>&gt;(epics::pvData::freeze(arr));</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line">...</div><div class="line">static svectorindtype devSVIMySupport = {{5,0,0,0,0}, &amp;read_my_array};</div><div class="line">...</div></div><!-- fragment --><p>Device support code for svectorout will access the shared_vector assigned to VAL. Since the array data is immutable, references may be safely passed to other threads.</p>
<h1><a class="anchor" id="qsrv_columnar"></a>
columnarin/out and statBin record types</h1>
<p>The columnarin/out and statBin types may be understood as storing a collection of named arrays of POD or string types. Depending on the LAY field, this collection can either be presented as a group of NTScalarArray sub-structures (LAY="Composite"), or as a single NTTable with the arrays becoming columns (LAY="Table").</p>
<p>At this point, the only difference between columnarin and columnarout is the presence of an INP vs. OUT field.</p>
<p>In either case, device support init_record() must use the multiArray::add_column() or multiArray::add_columns() helper methods to define column name, type, and optionally label (used with NTTable only).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;columnarinRecord.h&gt;</span></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * record(columnarin, &quot;myrec&quot;) {</span></div><div class="line"><span class="comment"> *     field(DTYP, &quot;My Support&quot;)</span></div><div class="line"><span class="comment"> *     field(LAY , &quot;Table&quot;) # default is Composite</span></div><div class="line"><span class="comment"> * }</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span></div><div class="line">multiArray::Entry columns[] = {</div><div class="line">    {<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;Column A&quot;</span>, epics::pvData::pvString},</div><div class="line">    {<span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;Column B&quot;</span>, epics::pvData::pvDouble},</div><div class="line">    {0}, <span class="comment">// end</span></div><div class="line">};</div><div class="line"><span class="keyword">static</span></div><div class="line"><span class="keywordtype">long</span> init_record_my_table(dbCommon *pcommon) {</div><div class="line">    multiArray::add_columns(pcommon, columns);</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>Device support for the columnarin or statBin type will use multiArray::set_column() to assign shared_vector instances for each "column". In the case of LAY="Table" it is the responsibility for device support to ensure that all arrays/columns have the same number of rows.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span></div><div class="line"><span class="keywordtype">long</span> read_my_table(columnarinRecord *prec) {</div><div class="line">    epics::pvData::shared_vector&lt;std::string&gt; cola(2);</div><div class="line">    cola[0] = <span class="stringliteral">&quot;hello&quot;</span>;</div><div class="line">    cola[1] = <span class="stringliteral">&quot;world&quot;</span>;</div><div class="line"></div><div class="line">    epics::pvData::shared_vector&lt;double&gt; colb(2);</div><div class="line">    colb[0] = 1.0;</div><div class="line">    colb[1] = 2.0;</div><div class="line"></div><div class="line">    multiArray::set_column(prec, <span class="stringliteral">&quot;a&quot;</span>, epics::pvData::static_shared_vector_cast&lt;const void&gt;(epics::pvData::freeze(cola)));</div><div class="line">    multiArray::set_column(prec, <span class="stringliteral">&quot;b&quot;</span>, epics::pvData::static_shared_vector_cast&lt;const void&gt;(epics::pvData::freeze(colb)));</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line">...</div><div class="line">static columnarindtype devCOLIMySupport = {{5,0,0,&amp;init_record_my_table,0}, &amp;read_my_table};</div><div class="line">...</div></div><!-- fragment --><p>Device support for the columnarout type will use multiArray::get_column() to retrieve column arrays.</p>
<h2><a class="anchor" id="qsrv_statbin_softchannel"></a>
statBin default device support</h2>
<p>The statBin type is similar to columnarin with added fields, and a default device support where INP can be pointed to an array field (eg. aai or svectorin) to compute certain statistical values.</p>
<div class="fragment"><div class="line">record(aai, <span class="stringliteral">&quot;some:array&quot;</span>) { ... }</div><div class="line">record(<a class="code" href="namespacestat_bin.html">statBin</a>, <span class="stringliteral">&quot;my:stats&quot;</span>) {</div><div class="line">    field(INP, <span class="stringliteral">&quot;some:array&quot;</span>)</div><div class="line">    field(DEC, &quot;10&quot;) <span class="preprocessor"># decimate by 10.  aka. 10 input samples to one output bin.</span></div><div class="line"><span class="preprocessor">}</span></div></div><!-- fragment --><h1><a class="anchor" id="qsrv_ndain"></a>
ndain record type</h1>
<p>The ndain record type presents an NTNDArray structure a la. areaDetector. Some additional fields are added, notably W and H, and FTVL is omitted. Otherwise this type is similar to svectorin.</p>
<p>Currently only Gray scale images are supported.</p>
<p>See process_img() in pdbApp/src/demo.cpp for a more realistic example.</p>
<div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * record(ndain, &quot;myrec&quot;) {</span></div><div class="line"><span class="comment"> *     field(DTYP, &quot;My Support&quot;)</span></div><div class="line"><span class="comment"> * }</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="preprocessor">#include &lt;ndainRecord.h&gt;</span></div><div class="line">...</div><div class="line">static</div><div class="line"><span class="keywordtype">long</span> read_my_image(ndainRecord *prec) {</div><div class="line">    <span class="comment">// 3x2 8bit</span></div><div class="line">    prec-&gt;w = 3;</div><div class="line">    prec-&gt;h = 2;</div><div class="line">    epics::pvData::shared_vector&lt;epics::pvData::uint8&gt; arr(3*2);</div><div class="line">    <span class="comment">// width is innermost/contiguous</span></div><div class="line">    <span class="comment">// idx = h*prec-&gt;w + w</span></div><div class="line">    arr[0] = 1; <span class="comment">// 0x0</span></div><div class="line">    arr[1] = 2;</div><div class="line">    arr[2] = 3; <span class="comment">// 2x0</span></div><div class="line">    arr[3] = 4; <span class="comment">// 0x1</span></div><div class="line">    arr[4] = 5;</div><div class="line">    arr[5] = 6;</div><div class="line">    prec-&gt;val = epics::pvData::static_shared_vector_cast&lt;<span class="keyword">const</span> <span class="keywordtype">void</span>&gt;(epics::pvData::freeze(arr));</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line">...</div><div class="line">static ndaindtype devNDIMySupport = {{5,0,0,0,0}, &amp;read_my_image};</div><div class="line">...</div></div><!-- fragment --><h1><a class="anchor" id="qsrv_pvstructin"></a>
pvstructin record type</h1>
<p>By analogy, the pvstructin record type is to these special record types what aSub is the Base record types. A tool to be used when no other would be sufficient.</p>
<p>This record type allows device support to device an arbitrary pvData structure, which is done by placing a PVStructure pointer in the VAL field during init_record().</p>
<p>It is then the responsibility of device support to manipulate the (arbitrary) structure, and to set the appropriate bit(s) of the CHG bitmask when doing so.</p>
<p>A discussion of the proper handling of a PVStructure is outside the scope of this document. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
